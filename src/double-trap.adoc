[[header]]
:description: Double Trap Extensions
:company: RISC-V.org
:revdate: 01/2024
:revnumber: 0.7
:revremark: This document is in development state. See http://riscv.org/spec-state for details.
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:imagesdir: images
:title-logo-image: image:risc-v_logo.png[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
// needs to be changed? bug discussion started
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
:bibtex-file: src/double-trap.bib
:bibtex-order: appearance
:bibtex-style: ieee
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short

= Double Trap Extensions

// Preamble
[WARNING]
.This document is in the link:http://riscv.org/spec-state[Development state]
====
Assume everything can change. This draft specification will change before being
accepted as standard, so implementations made to this draft specification will
likely not conform to the future standard.
====

[preface]
=== Copyright and license information
This specification is licensed under the Creative Commons
Attribution 4.0 International License (CC-BY 4.0). The full
license text is available at
https://creativecommons.org/licenses/by/4.0/.

Copyright 2024 by RISC-V International.

[preface]
=== Contributors
This RISC-V specification has been contributed to directly or indirectly by:
Allen Baum, Andrew Waterman, Deepak Gupta, Earl Killian, Greg Favor, John
Hauser, and Ved Shanbhogue

== Double Trap

A double trap typically arises during a sensitive phase in trap handling
operations - when an exception or interrupt occurs while the trap handler, the
component responsible for managing these events, is in a non-reentrant state.
This non-reentrancy usually occurs in the early phase of trap handling, where
the trap handler hasn't yet preserved the necessary state to handle and resume
from the trap. The occurrence of a second trap during this phase can lead to an
overwrite of this critical state information, resulting in the loss of data
needed to recover from the initial trap. Trap handlers are designed to neither
enable interrupts nor cause exceptions during this phase of handling. However,
managing Hardware-Error exceptions, which may occur unpredictably, presents a
significant challenge in trap handler implementation due to the potential risk of
a double trap triggered by such a Hardware-Error exception cite:[PRIV].

Efficient and reliable fault handling is essential for ensuring robust
operation. The ISA Double Trap Extensions is devised to tackle situations where
conventional fault handling mechanisms fall short. Although a double trap
generally represents an irrecoverable condition and signals a critical error,
these extensions introduce strategies to manage such critical errors across
different privilege levels.

The following ISA extensions are defined to enhance fault handling capabilities:

* Ssdbltrp: This extension is designed to address double trap at privilege modes
  lower than M. It enables HS-mode to invoke a critical error handler in a
  virtual machine when a double trap occurs in VS-mode, and allows M-mode to
  invoke a critical error handler in the OS/Hypervisor when a double trap in
  S/HS-mode.

* Smdbltrp: This extension specifically addresses double trap in M-mode. When the
  Smrnmi extension cite:[SMRNMI] is also implemented, the Smdbltrp extension
  enables invocation of the RNMI handler on a double trap in M-mode to handle
  the critical error. When the Smrnmi extension is not implemented or if a
  double trap occurs during the RNMI handlers execution, the Smdbltrp extension
  facilitates transitioning the hart to a critical error state on a double trap
  in M-mode and enables the signaling the critical error to the platform.

* Sddbltrp: Aimed at improving error diagnosis and resolution, this extension
  supports external debugging of harts in a critical error state, resulting from
  a double trap in M-mode.

In addition to these, a non-ISA extension to the RISC-V Debug specification 1.0
is defined. This extension is intended for external debugging of harts in a
critical error state due to a double trap in M-mode and serves as a complement
to the Ssdbltrp ISA extension.

=== Ssdbltrp and Smdbltrp Operational Details

The Smdbltrp extension introduces an M-mode-disable-trap (`MDT`) field (bit 24)
to the `mstatus` CSR. Upon reset, the `MDT` field is set to 1. The Smdbltrp
extension introduces a new Exception Code (value = 0x10)  called the double
trap. The Ssdbltrp adds an S-mode-disable-trap (`SDT`) field (bit 23) to the
`mstatus` CSR and a double-trap-enable (`DTE`) field (bit 60) to the `menvcfg`
CSR. If the H-extension is implemented, Ssdbltrp also adds a `SDT` field
(bit 23) to the `vsstatus` CSR and a `DTE` field (bit 59) to the `henvcfg` CSR.
The bit 16 of the `medeleg` and the `hedeleg` CSR are read-only zero.

When `menvcfg.DTE` is zero, the implementation behaves as though Ssdbltrp is not
implemented. When Ssdbltrp is not implemented `mstatus.SDT`, `vsstatus.SDT`, and
`henvcfg.DTE` bits are read-only zero. When `henvcfg.DTE` is zero, the
implementation behaves as though Ssdbltrp is not implemented for VS-mode and the
`vsstatus.SDT` bit is read-only zero.

When a trap is to be taken into privilege mode `x`, if the `__x__DT` bit is
currently 0, it is then set to 1, and the trap is delivered as expected. However,
if `__x__DT` is already set to 1, a critical error condition occurs. Additionally,
when the Smrnmi extension is implemented, encountering an exception
while executing in M-mode with the `mnstatus.NMIE` bit clear similarly results in
a critical error condition. The trap that caused the critical error condition is
henceforth called the initial trap.

[NOTE]
====
A trap handler should clear the `__x__DT` bit only after it has saved the state,
including `__x__cause`, `__x__epc`, and `__x__tval` among others, needed to
resume from the trap, and the trap handler is reentrant.
====

In the event of a critical error condition, the handling varies based on the
privilege mode:

* At privilege mode less than M: The hart raises a double trap exception and
  a trap is taken into M-mode as follows:

  ** The hart writes registers, except `mcause` and `mtval2`, with the same
     information that the initial trap would have written if it was taken into
     M-mode. The `mtval2` register is then set to what would be otherwise
     written into the `mcause` register by the initial trap. The Exception Code
     in the `mcause` register is set to 16, the double trap exception code, and
     its Interrupt field is set to 0.

[NOTE]
====
The consequence of this specification is that if a critical error condition was
caused by a guest page-fault, then the GPA will not be available in `mtval2`
when the double trap is delivered to M-mode.  This condition arises if the
HS-mode uses the hypervisor load/store instructions when `sstatus.SDT` is 1 and
the instruction raises a guest page-fault. The use of a hypervisor load/store
instruction in this phase of trap handling is not common. However, not recording
the GPA is considered benign because, if required, it can still be obtained
-- albeit with added effort -- by software through the process of walking the page
tables.

For a double trap to M-mode that originates due to a critical error detected in
VS-mode, the M-mode should delegate the double trap exception to HS-mode. This is
accomplished by copying the values of the M-mode CSRs updated by the double trap
to the corresponding HS-mode CSRs and using a `MRET` to resume execution at
HS-mode at the address held in `stvec`.

Supervisor Software Events (SSE) cite:[SSE], an extension to the SBI, provide a
mechanism for supervisor software to register and service system events
emanating from an SBI Implementation, such as firmware or a hypervisor. These
events, which hold higher priority, are processed even when the OS is in a
critical section with interrupts disabled, thus being orthogonal to normal OS
operations. The primary use case for SSE is in situations where event handling
cannot afford the delay caused by interrupt masking in critical sections in the
OS. For instance, in the event of a double trap, HS-mode and M-mode can utilize
the SSE mechanism to invoke a critical-error handler in VS-mode or S/HS-mode,
respectively. Additionally, the implementation of an SSE protocol can be
considered as an optional measure to aid in the recovery from such critical
errors.
====

<<<

* In M-mode, when the Smrnmi extension is implemented and `mnstatus.NMIE` is 1,
  the hart invokes the RNMI handler as follows:

  ** The `mnepc` register is written with the value that the initial trap would
     have written to the `mepc` register. The privilege mode information fields
     in the `mnstatus` register are written to indicate M-mode and its `NMIE`
     field is set to 0. No other registers are written. The Exception Code in
     the `mncause` register is set to 16, the double trap exception code, and
     its Interrupt field is set to 0.

[NOTE]
====
The consequence of this specification is that while the RNMI handler is invoked
to notify the occurrence of a double trap in M-mode, the RNMI handler is not
provided with any information about the initial trap that triggered the double
trap. A double trap generally represents an irrecoverable condition. Invoking
the RNMI handler enables performing actions such as capturing crash dumps and
preparing the system to shutdown and/or restart in a controlled manner.
====

* In M-mode, when the Smrnmi extension is implemented and `mnstatus.NMIE` is 0,
  or if the Smrnmi extension is not implemented, the hart enters a critical-error
  state without updating any architectural state. This state involves ceasing
  execution, disabling all interrupts (including NMIs), and asserting a
  `critical-error` signal to the platform.

[NOTE]
====
The actions performed by the platform on assertion of a `critical-error` signal
by a hart are platform specific. The range of possible actions include restarting
the affected hart or restarting the entire platform among others.
====

An `__x__RET` instruction sets the `__x__DT` bit to 0.

[NOTE]
====
Resetting of the `__x__DT` by an `__x__RET` enables the trap handler to detect
double trap occuring during the tail phase, where it restores critical state
in preparation for resuming execution after the trap.
====

<<<

=== Sddbltrp Operational Details

The Sddbltrp extension introduces a read-only previous-critical-error (`pcerr`)
field (bit 19) to the `dcsr` CSR.

If Sddbltrp is not implemented, a hart that is in critical-error state does not
enter Debug Mode when requested by a halt request from the Debug Module.

If Sddbltrp is implemented, a hart in critical-error state enters Debug Mode
with the `pcerr` bit in `dcsr` set to 1 upon receiving a halt request from the
Debug Module. Resuming from Debug Mode with `pcerr` is 1, returns the hart to
the critical-error state.

=== Non-ISA Debug Module (DM) Extension

The RISC-V Debug 1.0 specification is extended with a new optional control bit
suppress-critical-error-signal (`scerr`), defined in the `dmcs2` register
(bit 12) of the DM, to manage the `critical-error` signal. 

When `scerr` is set to 1, the `critical-error` signal asserted by any hart
associated with that DM is masked and prevented from causing its normal
platform specified action.

A new read-only field (bit 25) any-hart-in-critical-error (`anycerr`)
is defined in the `dmstatus` register of the DM. This bit is 1 if any hart
associated with the DM, irrespective of the value held in `hartsel`, asserts its
`critical-error` signal, before any masking of the request by `scerr`.

[NOTE]
====
The `scerr` control enables an external debugger to disable the actions that a
platform would normally perform when a hart asserts its `critical-error` signal.
This allows the external debugger to enter Debug Mode, by issuing a halt
request, in a hart that is in critical-error state and investigate the cause of
a double trap.

The `anycerr` status bit enables an external debugger to determine if any of the
harts associated with the DM are in a critical-error state.
====

[bibliography]
== Bibliography

bibliography::[]
