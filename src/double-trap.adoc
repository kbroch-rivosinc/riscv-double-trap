[[header]]
:description: Double Trap Extensions
:company: RISC-V.org
:revdate: 03/2024
:revnumber: 0.7
:revremark: This document is in development state. See http://riscv.org/spec-state for details.
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:imagesdir: images
:title-logo-image: image:risc-v_logo.png[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
// needs to be changed? bug discussion started
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
:bibtex-file: src/double-trap.bib
:bibtex-order: appearance
:bibtex-style: ieee
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short

= Double Trap Extensions

// Preamble
[WARNING]
.This document is in the link:http://riscv.org/spec-state[Development state]
====
Assume everything can change. This draft specification will change before being
accepted as standard, so implementations made to this draft specification will
likely not conform to the future standard.
====

[preface]
=== Copyright and license information
This specification is licensed under the Creative Commons
Attribution 4.0 International License (CC-BY 4.0). The full
license text is available at
https://creativecommons.org/licenses/by/4.0/.

Copyright 2024 by RISC-V International.

[preface]
=== Contributors
This RISC-V specification has been contributed to directly or indirectly by:
Allen Baum, Andrew Waterman, Deepak Gupta, Earl Killian, Greg Favor, John
Hauser, Joshua Scheid, Paul Donahue, and Ved Shanbhogue

== Double Trap

A double trap typically arises during a sensitive phase in trap handling
operations -- when an exception or interrupt occurs while the trap handler (the
component responsible for managing these events) is in a non-reentrant state.
This non-reentrancy usually occurs in the early phase of trap handling, wherein
the trap handler has not yet preserved the necessary state to handle and resume
from the trap. The occurrence of a trap during this phase can lead to an
overwrite of critical state information, resulting in the loss of data needed to
recover from the initial trap. Trap handlers are designed to neither enable
interrupts nor cause exceptions during this phase of handling. However, managing
Hardware-Error exceptions cite:[PRIV], which may occur unpredictably, presents
significant challenges in trap handler implementation due to the potential risk
of a double trap.

The ISA Double Trap Extensions are devised to tackle situations where
conventional fault handling mechanisms fall short. Although a double trap
generally is an irrecoverable condition and signals a critical error, these
extensions introduce strategies to manage such errors across privilege levels.

The following ISA extensions are defined to enhance fault handling capabilities:

* Ssdbltrp: This extension is designed to address double trap at privilege modes
  lower than M. It enables HS-mode to invoke a critical error handler in a
  virtual machine on a double trap in VS-mode, and allows M-mode to invoke a
  critical error handler in the OS/Hypervisor on a double trap in S/HS-mode.

* Smdbltrp: This extension addresses double trap in M-mode. When the Smrnmi
  extension cite:[SMRNMI] is also implemented, this extension enables invocation
  of the RNMI handler on a double trap in M-mode to handle the critical error.
  When the Smrnmi extension is not implemented or if a double trap occurs during
  the RNMI handler's execution, this extension facilitates transitioning the
  hart to a critical error state and enables signaling the critical error to the
  platform.

* Sddbltrp: Aimed at improving error diagnosis and resolution, this extension
  supports external debugging of harts in a critical error state, resulting from
  a double trap in M-mode.

In addition to these, a non-ISA extension to the RISC-V Debug specification 1.0
is defined, intended for external debugging of harts in a critical error state
due to a double trap in M-mode, serving as a complement to the Ssdbltrp extension.

<<<

=== Ssdbltrp Operational Details

The Ssdbltrp adds an S-mode-disable-trap (`SDT`) field (bit 24) to the `mstatus`
CSR and a double-trap-enable (`DTE`) field (bit 59) to the `menvcfg` CSR. If the
H-extension is implemented, Ssdbltrp also adds a `SDT` field (bit 24) to the
`vsstatus` CSR and a `DTE` field (bit 59) to the `henvcfg` CSR.

When the `SDT` bit is set to 1 by an explicit CSR write, the `SIE` (Supervisor
Interrupt Enable) bit is cleared to 0. This clearing occurs regardless of the
value written, if any, to the `SIE` bit by the same write. The `SIE` bit can
only be set to 1 by a CSR write if the `SDT` bit is being set to 0 by the same
write or is already 0.

An Exception Code (value = 16) called the double trap is introduced. The bit 16
of the `medeleg` and the `hedeleg` CSRs are read-only zero as the double trap is
not delegatable.

When `menvcfg.DTE` is zero, the implementation behaves as though Ssdbltrp is not
implemented. When Ssdbltrp is not implemented `mstatus.SDT`, `vsstatus.SDT`, and
`henvcfg.DTE` bits are read-only zero. When `henvcfg.DTE` is zero, the
implementation behaves as though Ssdbltrp is not implemented for VS-mode and the
`vsstatus.SDT` bit is read-only zero.

The Ssdbltrap extension requires the implementation of the `mtval2` CSR.

When a trap is to be taken into privilege mode S, if the `SDT` bit is currently
0, it is then set to 1, and the trap is delivered as expected. However, if `SDT`
is already set to 1, a critical error condition occurs. The trap that caused the
critical error condition is henceforth called the _unexpected trap_.

[NOTE]
====
A trap handler after saving the state needed for resuming from the trap,
including `scause`, `sepc`, and `stval` among others, should clear the `SDT` bit
when it is reentrant.
====

An `SRET` instruction sets the `SDT` bit to 0.

[NOTE]
====
Resetting of the `SDT` by an `SRET` enables the trap handler to detect double
trap occuring during the tail phase, where it restores critical state in
preparation for resuming execution after the trap.
====

In the event of a critical error condition, the hart raises a double trap
exception and a trap is taken into M-mode. To deliver this trap, the hart writes
registers, except `mcause` and `mtval2`, with the same information that the
_unexpected trap_ would have written if it was taken into M-mode. The `mtval2`
register is then set to what would be otherwise written into the `mcause`
register by the _unexpected trap_. The `mcause` register is set to 16, the
double trap exception code.

[NOTE]
====
The consequence of this specification is that if a critical error condition was
caused by a guest page-fault, then the GPA will not be available in `mtval2`
when the double trap is delivered to M-mode. This condition arises if the
HS-mode invokes a hypervisor virtual-machine load or store instruction when
`SDT` is 1 and the instruction raises a guest page-fault. The use of such an
instruction in this phase of trap handling is not common. However, not recording
the GPA is considered benign because, if required, it can still be obtained
-- albeit with added effort -- through the process of walking the page tables.

For a double trap originating in VS-mode, M-mode should redirect the exception
to HS-mode by copying the values of M-mode CSRs updated by the trap to HS-mode
CSRs and should use an `MRET` to resume execution at the address in `stvec`.

Supervisor Software Events (SSE) cite:[SSE], an extension to the SBI, provide a
mechanism for supervisor software to register and service system events
emanating from an SBI implementation, such as firmware or a hypervisor. In the
event of a double trap, HS-mode and M-mode can utilize the SSE mechanism to
invoke a critical-error handler in VS-mode or S/HS-mode, respectively.
Additionally, the implementation of an SSE protocol can be considered as an
optional measure to aid in the recovery from such critical errors.
====

<<<

=== Smdbltrp Operational Details

The Smdbltrp extension introduces an M-mode-disable-trap (`MDT`) field (bit 45)
to the `mstatus` CSR for RV64. For RV32, this field is located in the `mstatush`
CSR at bit position 13. Upon reset, the `MDT` field is set to 1. 

When the `MDT` bit is set to 1 by an explicit CSR write, the `MIE` (Machine
Interrupt Enable) bit is cleared to 0. For RV64, this clearing occurs regardless
of the value written, if any, to the `MIE` bit by the same write. The `MIE` bit
can only be set to 1 by a CSR write if the `MDT` bit is already 0 or, for
RV64, is being set to 0 by the same operation (For RV32, the `MDT` bit is
in `mstatush` and the `MIE` bit in `mstatus` register).

An Exception Code (value = 16) called the double trap is introduced.

When a trap is to be taken into M-mode, if the `MDT` bit is currently 0, it is
then set to 1, and the trap is delivered as expected. However, if `MDT` is
already set to 1, a critical error condition occurs. Additionally, when the
Smrnmi extension is implemented, encountering an exception while executing in
M-mode with the `mnstatus.NMIE` set to 0 similarly results in a critical error
condition. The trap that caused the critical error condition is henceforth
called the _unexpected trap_.

An `MRET` instruction sets the `MDT` bit to 0.

In the event of a critical error condition, the handling is as follows:

* When the Smrnmi extension is implemented and `mnstatus.NMIE` is 1, the hart
  invokes the RNMI handler as follows:

  ** The `mnepc` and `mncause` registers are written with the values that the
     _unexpected trap_ would have written to the `mepc` and `mcause` registers
     respectively. The privilege mode information fields in the `mnstatus`
     register are written to indicate M-mode and its `NMIE` field is set to 0.

[NOTE]
====
The consequence of this specification is that on occurrence of double trap the
RNMI handler is not provided with information that a trap would report in the
`mtval` and the `mtval2` registers. This information, if needed, may be obtained
by the RNMI handler by decoding the instruction at the address in `mepc` and
examining its source register contents.
====

* When the Smrnmi extension is not implemented, or if the Smrnmi extension is
  implemented and `mnstatus.NMIE` is 0, the hart enters a critical-error state
  without updating any architectural state including the `pc`. This state
  involves ceasing execution, disabling all interrupts (including NMIs), and
  asserting a `critical-error` signal to the platform.

[NOTE]
====
The actions performed by the platform on assertion of a `critical-error` signal
by a hart are platform specific. The range of possible actions include restarting
the affected hart or restarting the entire platform among others.
====

<<<

=== Sddbltrp Operational Details

The Sddbltrp extension introduces a read-only previous-critical-error (`pcerr`)
field (bit 19) to the `dcsr` CSR. If Sddbltrp is not implemented, a hart that is
in critical error state does not enter Debug Mode when requested by a halt
request from the Debug Module (DM). If Sddbltrp is implemented, a hart in
critical error state enters Debug Mode upon a halt request from the DM. Upon
this transition to Debug Mode, the `pcerr` field of `dcsr` is set to 1, and
`dpc` set to the `pc`. Resuming from Debug Mode with `pcerr` is 1 returns the
hart to the critical error state.

<<<

=== Non-ISA Debug Module (DM) Extension

The RISC-V Debug 1.0 specification is extended with a new optional control bit
suppress-critical-error-signal (`scerr`), defined in the `dmcs2` register
(bit 12) of the DM, to manage the `critical-error` signal. When `scerr` is set
to 1, the `critical-error` signal asserted by any hart associated with that DM
is masked and prevented from causing its normal platform specified action.

[NOTE]
====
The `scerr` control enables an external debugger to disable the actions that a
platform would normally perform when a hart asserts its `critical-error` signal.
This allows the external debugger to enter Debug Mode in a hart that is in
critical error state and investigate the cause of a double trap.
====

A new read-only field (bit 25) any-hart-in-critical-error (`anycerr`)
is defined in the `dmstatus` register of the DM. This bit is 1 if any hart
associated with the DM, irrespective of the value held in `hartsel`, asserts its
`critical-error` signal, before any masking of the request by `scerr`.

[NOTE]
====
The `anycerr` status bit enables an external debugger to determine if any of the
harts associated with the DM are in a critical error state.
====

[bibliography]
== Bibliography

bibliography::[]
