[[header]]
:description: Double Trap Extensions
:company: RISC-V.org
:revdate: 01/2024
:revnumber: 0.7
:revremark: This document is in development state. See http://riscv.org/spec-state for details.
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:imagesdir: images
:title-logo-image: image:risc-v_logo.png[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
// needs to be changed? bug discussion started
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
:bibtex-file: src/double-trap.bib
:bibtex-order: appearance
:bibtex-style: ieee
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short

= Double Trap Extensions

// Preamble
[WARNING]
.This document is in the link:http://riscv.org/spec-state[Development state]
====
Assume everything can change. This draft specification will change before being
accepted as standard, so implementations made to this draft specification will
likely not conform to the future standard.
====

[preface]
=== Copyright and license information
This specification is licensed under the Creative Commons
Attribution 4.0 International License (CC-BY 4.0). The full
license text is available at
https://creativecommons.org/licenses/by/4.0/.

Copyright 2024 by RISC-V International.

[preface]
=== Contributors
This RISC-V specification has been contributed to directly or indirectly by:
Allen Baum, Andrew Waterman, Deepak Gupta, Earl Killian, Greg Favor, John
Hauser, and Ved Shanbhogue

== Double Trap

A double trap condition typically arises during a sensitive phase in trap
handling operations - when an exception or interrupt occurs while the trap
handler, the component responsible for managing these events, is in a
non-reentrant state. This non-reentrancy usually occurs in the early phase of
trap handling, where the trap handler hasn't yet preserved the necessary state
to handle and resume from the trap. The occurrence of a second trap during this
phase can lead to an overwrite of this critical state information, resulting in
the loss of data needed to recover from the initial trap. Trap handlers are
designed to neither enable interrupts nor cause exceptions during this phase of
handling. However, managing Hardware-Error exceptions, which may occur
unpredictably, presents a significant challenge in trap handler implementation
due to the potential risk of a double trap condition triggered by such a
Hardware-Error exception cite:[PRIV].

Efficient and reliable fault handling is essential for ensuring robust
operation. The ISA Double Trap Extensions is devised to tackle situations where
conventional fault handling mechanisms fall short. Although a double trap
generally represents an irrecoverable condition and signals a critical error,
these extensions introduce strategies to manage such critical errors across
different privilege levels.

The following ISA extensions are defined to enhance fault handling capabilities:

* Ssdbltrp: This extension is designed to address double trap conditions at
  privilege modes lower than M. It enables HS-mode to invoke a critical error
  handler in a virtual machine when a double trap condition occurs in VS-mode,
  and allows M-mode to invoke a critical error handler in the OS/Hypervisor when
  a double trap condition occurs in S/HS-mode.

* Smdbltrp: This extension specifically addresses double trap conditions in
  M-mode. It facilitates transitioning the hart to a critical error state on a
  double trap condition in M-mode and enables the request for a platform reset.

* Sddbltrp: Aimed at improving error diagnosis and resolution, this extension
  supports external debugging of harts in a critical error state, particularly
  resulting from a double trap condition in M-mode.

In addition to these, a non-ISA extension to the RISC-V Debug specification 1.0
is defined. This extension is intended for external debugging of harts in a
critical error state due to a double trap condition in M-mode and serves as a
complement to the Ssdbltrp ISA extension.

=== Ssdbltrp and Smdbltrp Operational Details

The Smdbltrp extension introduces an M-mode-disable-trap (`MDT`) field (bit 24)
to the `mstatus` CSR. Upon reset, the `MDT` field is set to 1. The Smdbltrap
extension introduces a new Exception Code called the double trap. The bit
corresponding to the double trap Exception Code is read-only zero in
`medeleg` CSR.

The Ssdbltrp adds an S-mode-disable-trap (`SDT`) field (bit 23) to the `mstatus`
CSR and a double-trap-enable (`DTE`) field (bit 60) to the `menvcfg` CSR. If the
H-extension is implemented, Ssdbltrp also adds a `SDT` field (bit 23) to the
`vsstatus` CSR and a `DTE` field (bit 60) to the `henvcfg` CSR. When
`menvcfg.DTE` is zero, the implementation behaves as though Ssdbltrp is not
implemented. When Ssdbltrp is not implemented `mstatus.SDT`, `vsstatus.SDT`, and
`henvcfg.DTE` bits are read-only zero. When `henvcfg.DTE` is zero, the
implementation behaves as though Ssdbltrp is not implemented for VS-mode and the
`vsstatus.SDT` bit is read-only zero. The bit corresponding to the double trap
Exception Code is read-only zero in `hedeleg` CSR.

When a trap is to be taken into privilege mode `x`, if the `__x__DT` bit is
currently 0, it is then set to 1, and the trap is delivered as expected. However,
if `__x__DT` is already set to 1, a double trap condition occurs. Additionally,
when the Smrnmi extension is implemented, encountering an exception while
executing in M-mode with the `mnstatus.NMIE` bit clear similarly results in a
double trap condition.

In the event of a double trap, the handling varies based on the privilege mode:

* At privilege mode less than M: The hart redirects the trap to the next higher
  privilege mode but with a transformed Exception Code. This redirection
  delivers the trap as if it was not delegated to the mode where the double trap
  occurred. For VS-mode, the next higher privilege mode is HS-mode, and for
  S/HS-mode, it is M-mode.                                                     +
                                                                               +
  The Exception Code transformation process is as follows:

  ** If the trap is redirected to S/HS-mode, the value held in `scause` register
     value is copied to `htval` register. Then the `Exception Code` field of
     `scause` register is updated to double trap Exception Code and the
     `Interrupt` field of the `scause` register is set to 0.

  ** If the trap is redirected to M-mode, the value held in `mcause` register
     value is copied to `mtval2` register. Then the `Exception Cause` field of
     `mcause` register is updated to double trap Exception Code and the
     `Interrupt` field of the `mcause` register is set to 0.

* In M-mode: The hart enters a critical-error state without updating any
  architectural state. This state involves ceasing execution, disabling all
  interrupts (including NMIs), and asserting a `platform-reset-request` to the
  platform. This signals the necessity for a reset of the entire platform.

An `__x__RET` instruction, sets the `__x__DT` bit to 0.

[NOTE]
====
The trap handler should clear the `__x__DT` bit only after it has saved the
state, including `__x__cause`, `__x__epc`, and `__x__tval` among others, needed
to resume from the trap, and the trap handler is reentrant.

Supervisor Software Events (SSE) cite:[SSE], an extension to the SBI, provide a
mechanism for supervisor software to register and service system events
emanating from an SBI Implementation, such as firmware or a hypervisor. These
events, which hold higher priority, are processed even when the OS is in a
critical section with interrupts disabled, thus being orthogonal to normal OS
operations. The primary use case for SSE is in situations where event handling
cannot afford the delay caused by interrupt masking in critical sections in the
OS. For instance, in the event of a double trap condition, HS-mode and M-mode
can utilize the SSE mechanism to invoke a critical-error handler in VS-mode or
S/HS-mode, respectively. Additionally, the implementation of an SSE protocol can
be considered as an optional measure to aid in the recovery from double trap
conditions.

An `__x__RET` clearing the `__x__DT` bit enables the trap handler to detect
double trap conditions during the tail phase, where it restores critical state
in preparation for resuming execution after the trap.
====

<<<

=== Sddbltrp Operational Details

The Sddbltrp extension introduces a read-only previous-critical-error (`pcerr`)
field (bit 19) to the `dcsr` CSR.

If Sddbltrp is not implemented a hart that is in critical-error state does not
enter Debug Mode when requested by a halt request from the Debug Module.

If Sddbltrp is implemented, a hart in critical-error state enters Debug Mode
with the `pcerr` bit in `dcsr` set to 1 upon receiving a halt request from the
Debug Module. Resuming from Debug Mode with `pcerr` is 1, returns the hart to
the critical-error state.

=== Non-ISA Debug Module (DM) Extension

The RISC-V Debug 1.0 specification is extended with a new optional control bit
disable-platform-reset-request (`disprr`), defined in the `dmcs2` register
(bit 12) of the DM, to manage `platform-reset-request`. When `disprr` is set to
1, the `platform-reset-request` asserted by any hart associated with that DM is
masked. A new read-only field (bit 25) any-hart-platform-reset-request (`anyprr`)
is defined in the `dmstatus` register of the DM. This bit is 1 if any of the
harts associated with the DM assert their `platform-reset-request`, before any
masking of the request by `disprr`.

[NOTE]
====
The `disprr` control enables an external debugger to disable the reset and
instead enter Debug Mode, by issuing a halt request, in a hart that is in
critical-error state and investigate the cause of a double trap condition.

The `anyprr` status bit enables an external debugger to determine if any of the
hart associated with the DM are in a critical-error state.
====

[bibliography]
== Bibliography

bibliography::[]
